package main

import (
	"bytes"
	"fmt"
	"strings"
)

// See: http://elixir.free-electrons.com/linux/v3.12/source/lib/kobject_uevent.c#L45

const (
	ADD     KObjAction = "add"
	REMOVE  KObjAction = "remove"
	CHANGE  KObjAction = "change"
	MOVE    KObjAction = "move"
	ONLINE  KObjAction = "online"
	OFFLINE KObjAction = "offline"
)

type KObjAction string

func ParseKObjAction(raw string) (a KObjAction, err error) {
	a = KObjAction(raw)
	switch a {
	case ADD, REMOVE, CHANGE, MOVE, ONLINE, OFFLINE:
	default:
		err = fmt.Errorf("unknow kobject action (got: %s)", raw)
	}
	return
}

type UEvent struct {
	Action KObjAction
	KObj   string
	Env    map[string]string
}

// Ex:
// add@/devices/pci0000:00/0000:00:14.0/usb2/2-1/2-1:1.2/0003:04F2:0976.0008/hidraw/hidraw4ACTION=addDEVPATH=/devices/pci0000:00/0000:00:14.0/usb2/2-1/2-1:1.2/0003:04F2:0976.0008/hidraw/hidraw4SUBSYSTEM=hidrawMAJOR=247MINOR=4DEVNAME=hidraw4SEQNUM=2569
// []byte{0x61, 0x64, 0x64, 0x40, 0x2f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x30, 0x30, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x2f, 0x30, 0x30, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x3a, 0x31, 0x34, 0x2e, 0x30, 0x2f, 0x75, 0x73, 0x62, 0x32, 0x2f, 0x32, 0x2d, 0x31, 0x2f, 0x32, 0x2d, 0x31, 0x3a, 0x31, 0x2e, 0x32, 0x2f, 0x30, 0x30, 0x30, 0x33, 0x3a, 0x30, 0x34, 0x46, 0x32, 0x3a, 0x30, 0x39, 0x37, 0x36, 0x2e, 0x30, 0x30, 0x30, 0x38, 0x2f, 0x68, 0x69, 0x64, 0x72, 0x61, 0x77, 0x2f, 0x68, 0x69, 0x64, 0x72, 0x61, 0x77, 0x34, 0x0, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x3d, 0x61, 0x64, 0x64, 0x0, 0x44, 0x45, 0x56, 0x50, 0x41, 0x54, 0x48, 0x3d, 0x2f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2f, 0x70, 0x63, 0x69, 0x30, 0x30, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x2f, 0x30, 0x30, 0x30, 0x30, 0x3a, 0x30, 0x30, 0x3a, 0x31, 0x34, 0x2e, 0x30, 0x2f, 0x75, 0x73, 0x62, 0x32, 0x2f, 0x32, 0x2d, 0x31, 0x2f, 0x32, 0x2d, 0x31, 0x3a, 0x31, 0x2e, 0x32, 0x2f, 0x30, 0x30, 0x30, 0x33, 0x3a, 0x30, 0x34, 0x46, 0x32, 0x3a, 0x30, 0x39, 0x37, 0x36, 0x2e, 0x30, 0x30, 0x30, 0x38, 0x2f, 0x68, 0x69, 0x64, 0x72, 0x61, 0x77, 0x2f, 0x68, 0x69, 0x64, 0x72, 0x61, 0x77, 0x34, 0x0, 0x53, 0x55, 0x42, 0x53, 0x59, 0x53, 0x54, 0x45, 0x4d, 0x3d, 0x68, 0x69, 0x64, 0x72, 0x61, 0x77, 0x0, 0x4d, 0x41, 0x4a, 0x4f, 0x52, 0x3d, 0x32, 0x34, 0x37, 0x0, 0x4d, 0x49, 0x4e, 0x4f, 0x52, 0x3d, 0x34, 0x0, 0x44, 0x45, 0x56, 0x4e, 0x41, 0x4d, 0x45, 0x3d, 0x68, 0x69, 0x64, 0x72, 0x61, 0x77, 0x34, 0x0, 0x53, 0x45, 0x51, 0x4e, 0x55, 0x4d, 0x3d, 0x32, 0x35, 0x36, 0x39, 0x0}

func ParseUEvent(raw []byte) (e *UEvent, err error) {
	// msg := string(raw)
	fields := bytes.Split(raw, []byte{0x00})

	if len(fields) == 0 {
		err = fmt.Errorf("Wrong uevent format")
		return
	}

	headers := strings.Split(string(fields[0]), "@")
	if len(headers) != 2 {
		err = fmt.Errorf("Wrong uevent header")
		return
	}

	action, err := ParseKObjAction(headers[0])
	if err != nil {
		return
	}

	e = &UEvent{
		Action: action,
		KObj:   headers[1],
		Env:    make(map[string]string, 0),
	}

	for _, envs := range fields[1 : len(fields)-1] {
		// log.Printf("v: %s", envs)
		env := strings.Split(string(envs), "=")
		if len(env) != 2 {
			err = fmt.Errorf("Wrong uevent env")
			return
		}
		e.Env[env[0]] = env[1]
	}
	// log.Printf("Fields: %#v\n", fields[1:])
	return
}
